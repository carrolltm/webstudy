---
typora-root-url: 图片
typora-copy-images-to: 图片
---

# 面试问题

链接：[手写35道面试高频题](https://juejin.cn/post/6870043180444680200)

## 计算机网络

#### 三握四挥：tcp传输层

##### 三次握手

syn同步位（只有连接请求或者连接请求的接受为1），seq是序号位（随机产生） ACK确认位（与ack【确认号字段】搭配使用）

ack是对上一个号的确认

![image-20210106150947279](/image-20210106150947279.png)

![image-20210106145112108](/image-20210106145112108.png)

##### 四次挥手

![image-20210106145203649](/image-20210106145203649.png)

FIN结束位，

![image-20210106151414292](/image-20210106151414292.png)

##### syn攻击

tcp连接时第二次和第三次分别分配缓存和变量，会产生syn泛洪攻击。就是攻击者不进行第三步反馈

![image-20210106150632296](/image-20210106150632296.png)

解决办法：设置syncookie

##### 为什么前面需要三次握手，后面却是四次挥手

​	这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。

##### TCP连接第三次可以发送数据吗

​	客户端发送这个报文之后，就进入established状态了。服务器收到这个报文之后，也进入established状态。

​	TCP标准规定，第三次握手的报文，可以携带数据。因为此时客户端已经处于established状态了呀

![image-20210106151845094](/image-20210106151845094.png)

##### 全连接和半连接队列（三次握手）

第一种回答：

三次握手用于防止“已失效的连接请求报文段”，报文段没有丢失，而是在某个节点长时间滞留。
四次挥手：由于连接是全双工的。所以每个方向都必须单独进行关闭

因为在握手的时候服务端在listen状态，收到建立连接的syn报文后，将ack和syn放在一个报文里发送给对方，而关闭连接时，收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

第二种回答：

![image-20210106162130026](/image-20210106162130026.png)

![image-20210106162204037](/image-20210106162204037.png)

##### 链接：[三握四挥](https://zhuanlan.zhihu.com/p/53374516)

#### Https的工作原理

[https的工作原理](https://juejin.cn/post/6844903830916694030)

##### 什么是Https

​	HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。

HTTPS主要作用是：

（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;

（2）对网站服务器进行真实身份认证。

反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）:

- 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥
- 数据完整性：内容传输经过完整性校验
- 身份认证：第三方无法伪造服务端（客户端）身份

##### HTTPS如何解决HTTP上述问题?

​	**HTTP加上加密处理和认证以及完整性保护后即是HTTPS**。

![image-20210222161257421](/image-20210222161257421.png)

​	HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，**其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性**。

![image-20210222161329585](/image-20210222161329585.png)



#### Http和Https的区别

主要理解http是超文本传输协议，https主要是在http上+ssl（加密方法）传输

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。

- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。

- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

  [Http和Https的区别](https://www.runoob.com/w3cnote/http-vs-https.html)

  ##### 常见http状态码

  ​	![image-20210106201027234](/image-20210106201027234.png)

  200-请求成功

  301 资源被永久转移到其他URL

  404-请求资源不存在

  500-内部服务器错误

  [更具体的http状态码](https://blog.csdn.net/weixin_45495667/article/details/106967442)

#### get和post方法区别

**本质区别**：GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。
GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 header，服务器响应 100（continue），浏览器再发送 data，服务器响应 200（返回数据）。

1. GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
2. GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
3. GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
4. GET 请求只能进行 URL 编码，而 POST 支持多种编码方式。
5. GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
6. GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。对参数的数据类型，
7. GET 只接受 ASCII 字符，而 POST 没有限制。
8. GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
9. GET 参数通过 URL 传递，POST 放在 Request body 中。

#### Http1.0/1.1/2.0的区别

**HTTP2.0和HTTP1.X相比的新特性**

1. **新的二进制格式**，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
2. **多路复用**，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
3. **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
4. **服务端推送**，同SPDY一样，HTTP2.0也具有server push功能。

### 浏览器输入url到渲染页面后发生了什么

- DNS解析

- TCP连接（三次握手）

- 发送Http请求

- 服务器处理请求并返回HTTP报文

- 浏览器解析渲染页面

- 连接结束（四次挥手）

  

  1. 在浏览器地址栏输入URL
  2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
     1. 如果资源未缓存，发起新请求
     2. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
     3. 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：
        - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
        - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
  3. 浏览器解析URL获取协议，主机，端口，path
  4. 浏览器组装一个HTTP（GET）请求报文
  5. 浏览器获取主机ip地址，过程如下：
     1. 浏览器缓存
     2. 本机缓存
     3. hosts文件
     4. 路由器缓存
     5. ISP DNS缓存
     6. DNS递归查询（可能存在负载均衡导致每次IP不一样）
  6. 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：
     1. 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口
     2. 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
     3. 客户端发送ACK=Y+1， Seq=Z
  7. TCP链接建立后发送HTTP请求
  8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
  9. 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码
  10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
  11. 服务器将响应报文通过TCP连接发送回浏览器
  12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：
      1. 主动方发送Fin=1， Ack=Z， Seq= X报文
      2. 被动方发送ACK=X+1， Seq=Z报文
      3. 被动方发送Fin=1， ACK=X， Seq=Y报文
      4. 主动方发送ACK=Y， Seq=X报文
  13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
  14. 如果资源可缓存，进行缓存
  15. 对响应进行解码（例如gzip压缩）
  16. 根据资源类型决定如何处理（假设资源为HTML文档）
  17. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释
  18. 构建DOM树：
      1. Tokenizing：根据HTML规范将字符流解析为标记
      2. Lexing：词法分析将标记转换为对象并定义属性和规则
      3. DOM construction：根据HTML标记关系将对象组成DOM树
  19. 解析过程中遇到图片、样式表、js文件，启动下载
  20. 构建CSSOM树：
      1. Tokenizing：字符流转换为标记流
      2. Node：根据标记创建节点
      3. CSSOM：节点创建CSSOM树
  21. 根据DOM树和CSSOM树构建渲染树 :
      1. 从DOM树的根节点遍历所有可见节点，不可见节点包括：1) script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none
      2. 对每一个可见节点，找到恰当的CSSOM规则并应用
      3. 发布可视节点的内容和计算样式
  22. js解析如下：
      1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading
      2. HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容
      3. 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素
      4. 当文档完成解析，document.readState变成interactive
      5. 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()
      6. 浏览器在Document对象上触发DOMContentLoaded事件
      7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件
  23. 显示页面（HTML解析过程中会逐步显示页面）

### CDN

 主要是缓存静态资源：不怎么变换。

CDN的全称是Content Delivery Network，即内容分发网络。CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应。

资源上传cdn之后，当用户访问cdn的资源地址之后会经历下面的步骤：

1. 首先经过本地的dns解析，请求cname指向的那台cdn专用的dns服务器。
2. dns服务器返回全局负载均衡的服务器ip给用户
3. 用户请求全局负载均衡服务器，服务器根据ip返回所在区域的负载均衡服务器ip给用户
4. 用户请求区域负载均衡服务器，负载均衡服务器根据用户ip选择距离近的，并且存在用户所需内容的，负载比较合适的一台缓存服务器ip给用户。当没有对应内容的时候，会去上一级缓存服务器去找，直到找到资源所在的源站服务器，并且缓存在缓存服务器中。用户下一次在请求该资源，就可以就近拿缓存了。

注意： 因为cdn的负载均衡和就近选择缓存都是根据用户的ip来的，服务器只能拿到local dns的ip，也就是网络设置中设置的dns ip，如果这个设置的不合理，那么可能起不到加速的效果。可能就近找到的缓存服务器实际离得很远。

**总的来说：**主要答出负载均衡和缓存再就是dns解析这三部分就行了吧，通过**dns解析**到**全局负载均衡服务器**，然后再到区域的负载均衡，之后**根****据一些条件来找合适的缓存服务器**，如果第一次访问就从源站拿过来缓存。 需要注意的是一切都是根据请求的ip来的，如果ip不合理，那么可能起不到加速效果。缓存和负载均衡的思想在减轻服务器压力方面其实是很常见的。

**CDN对网络的优化作用主要体现在如下几个方面**
解决服务器端的“第一公里”问题
缓解甚至消除了不同运营商之间互联的瓶颈造成的影响
减轻了各省的出口带宽压力
缓解了骨干网的压力
优化了网上热点内容的分布

### 常见的跨域方式

[九种跨域方式](https://juejin.cn/post/6844903767226351623)

1. JSONP,解决老版本浏览器跨域数据访问问题,原理是web页面调用js文件不受浏览器同源策略限制,**所以通过script标签**可以进行跨域请求.

- 流程如下:
- 首先前端设置好回调参数,并将其作为URL的参数
- 服务器端收到请求后,通过该参数获取到回调函数名,并将数据放在参数中返回
- 收到结果后因为是script标签,所以浏览器当做脚本运行

1. cors,全称是跨域资源共享,允许浏览器向跨源服务器发出XMLHTTPRequest请求,从而克服了ajax只能同源使用的策略,实现cors的关键是服务器,只要服务器实现了cros接口,就可以跨域通信

   前端逻辑很简单,正常发起ajax请求即可,陈宫的关键在于服务器Access-Control-Allow-Origin,是否包含请求页面的域名,如果不包含的话,浏览器将认为这是一次失败的异步请求,将会调用xhr.onerror中的函数.
   cros使用简单,支持post方式,但是存在兼容问题
   浏览器将cors请求分为两类,简单请求和非常简单请求,对于简单请求,浏览器直接发出cors请求,就是在头信息之中增加一个origin字段,用于说明本次请求来自哪个协议+域名+端口,服务器根据这个值,决定是否同意本次请求,如果服务器同意本次请求,返回的响应中会多出几个头信息字段:
   Access-Control-Allow-Origin:返回origin的字段或者*
   Access-Control-Allow-Credentials,该字段可选,是一个bool值,表示是否允许发送cookie
   Access-Control-Express-Headers

2. 服务器代理:
   即当你有跨域的请求操作时发给后端,让后端帮你代为请求

3. 四种不常用的方式:
   location.hash
   Window.name
   postMessage

### CORS：

[廖雪峰](https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400)

[九种跨域方式](https://juejin.cn/post/6844903767226351623)

​	全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。

​	服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

​	Cors有简单请求和复杂请求： 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，**称为"预检"请求,**该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

[Http请求方法](https://blog.csdn.net/potato512/article/details/76696582)



### ipv4和ipv6的区别，子网掩码的作用

1:地址数量

​	IPv4 的 IP 地址是一个 32 位的二进制数，算下来有 2^32 个地址。

​	IPv6 采用 128 位地址长度，保守估计将提供 2^128 个地址，IPv4 的 2^96 倍。

2:传输速度

IPv6 使用的是固定报头，不像 IPv4 那样携带一堆冗长的数据，简短的报头提升了网络数据转发的效率。并且由于 IPv6 的路由表更小，聚合能力更强，保证了数据转发的路径更短，极大的提高了转发效率，IPv6 也消除了 IPv4 中常见的大部分地址冲突问题，并为设备提供了更多简化的连接和通信。

3:传输方式的安全性

IPv4 从未被认为是安全的，虽然越来越多的网站正在开启 SSL，但是依旧有大量的网站没有采用 HTTPS，但是 IPv6 从头到尾都是建立在安全的基础上的，在网络层认证与加密数据并对 IP 报文进行校验，为用户提供客户端到服务端的数据安全，保证数据不被劫持。

同时，相对比 IPv4， IPv6 协议对移动端更加友好，它可以增强移动终端的移动特性、安全特性、路由特性，同时降低网络部署的难度和投资。IPv6 增加了自动配置以及重配置技术，即插即用，对于 IP 地址等信息实现自动增删更新配置，提升 IPv6 的易管理性。

升级到ipv6也不容易，因为 IPv6 和 IPv4 是两个完全不兼容的协议，这个的升级改造需要花费的成本是巨大的。

### 进程之间如何通信

[腾讯面试](https://zhuanlan.zhihu.com/p/104713463)

1：管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

2： 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

3：消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。  **缺点：不适合某进程通信特别频繁。**

4:共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

5：信号量：信号量是一个**计数器**，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

6：socket：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。

## JavaScrip

### 如何判断 0.1 + 0.2 与 0.3 相等

**实践证明**

```js
console.log(0.1+0.2==0.3);
// false
console.log(0.1+0.2);
// 0.30000000000000004
console.log(0.1);
//0.1
```

原因在于数字运算中精度缺失的问题。在js中，数字采用的是双精度标准进行存储（理解为存储一个数值使用的二进制位数比较多,这样会更加精确)

> 对于整数来说，十进制的35会被存储为： `00100011` 其代表 `2^5 + 2^1 + 2^0`。
> 对于纯小数来说，十进制的0.375会被存储为： `0.011` 其代表 `1/2^2 + 1/2^3` = `1/4 + 1/8 = 0.375`
>
> 而对于像0.1这样的数值用二进制表示你就会发现无法整除，最后算下来会是 `0.000110011....`由于存储空间有限，最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。

​	在0.1 + 0.2这个式子中，0.1和0.2都是近似表示的，在他们相加的时候，两个近似值进行了计算，导致最后得到的值是`0.30000000000000004`，此时对于JS来说，其不够近似于0.3，于是就出现了`0.1 + 0.2 != 0.3` 这个现象。

​	在进行运算时，需要将其他进制的数值转换成二进制，然后再进行计算。

​	由于浮点数用二进制表达时是无穷的：

```
// 将0.1转换成二进制
console.log(0.1.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101

// 将0.2转换成二进制console.log(0.2.toString(2));  // 0.001100110011001100110011001100110011001100110011001101
```

​	在js中当出现这种无法整除的小数的时候就会取一个近似值，在js中如果这个近似值足够近似，那么js就会认为他就是那个值。	

```js
console.log(0.1000000000000001)  
// 0.1000000000000001 (中间14个0，会打印出它本身)

console.log(0.10000000000000001)   
// 0.1 (中间15个0，js会认为这两个值足够接近，所以会显示0.1)
console.log(0.10000000000000001==0.1);
// 前面是15个0，答案是true
```

​	IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加后，因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 `0.30000000000000004，`所以在进行算术计算时会产生误差。

> 64位比特又可分为三个部分：
>
> - 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
> - 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
> - 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

**解决办法**

1:自带的Number.EPSILON方法：就是容忍在一定误差范围内

```js
function numbersequal(a,b){ return Math.abs(a-b)<Number.EPSILON;
} 
var a=0.1+0.2, b=0.3;
console.log(numbersequal(a,b)); //true
```

2:把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。N>1.

```js
 console.log((0.1*1000+0.2*1000)/1000==0.3); 
//true
```



### 闭包

#### 闭包的产生

```js
function foo(){
    var a=1;
    var b=2;
    function bar(){
      return a+b;
    }
    return bar;
  }
  var bar = foo()
 console.log(bar()); 
```

当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。

#### 闭包的应用场景

**函数柯里化**

**模块化**

​	模块化是闭包最强大的一个应用场景

```js
(function () {
  var a = 10;
  var b = 20;

  function add(num1, num2) {
    var num1 = !!num1 ? num1 : a;
    var num2 = !!num2 ? num2 : b;

    return num1 + num2;
  }

  window.add = add;
})();

add(10, 20);
```



#### 解决闭包

```js
for (var a = 0; a<200; a++) { setTimeout(() => console.log(a), 1000) }
```

原因：产生了闭包，等函数执行完之后a的值已经是200了

##### 使用立即函数解决闭包

​		思路：匿名函数内的变量i与外部函数的变量i的引用关系断掉

```js
for (var a = 0; a <20; a++) {
           (function(index){
                    setTimeout(() => console.log(index), 1000) 
                }(a));
            }
```

##### 使用promise解决闭包

[promise的理解](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)

[廖学峰的promise](https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544)

[promise语法：resolve和reject](https://juejin.cn/post/6844903604009041928)

	const tasks=[];
	const output=function(index){
	    new Promise(
	      (resolve)=>{
	        setTimeout(() =>{ console.log(index);  resolve()}, 10) ;
	    })
	}         
	 
	for (var a = 0; a <20; a++) {
	        tasks.push(output(a));
	    }
	Promise.all(tasks).then(()=>{
	       console.log("全部打印成功");
	    })
#### 基本数据类型（7+1）

基本数据类型null，undefined，string，number，boolean，symbol(这是es6引入的一种新的原始数据 类型，表示独一无二的值)

引用数据类型：一般统称为对象类型，但细分的话有：对象（object）数组（Array）函数（Function) Data类型，RegExp 类型

注意：Symbol 生成一个全局唯一的值。写法：var symbol() :括号里面可以用字符串表示值，但其实括号里面的值没什么关系

![image-20210107132635423](/image-20210107132635423.png)



#### Javasc中reduce方法手动实现

![image-20210106153853419](/image-20210106153853419.png)

![image-20210106154027207](/image-20210106154027207.png)

注意：在没有初始值的空数组上调用 reduce 将报错

```js
<script>
     Array.prototype.reduce =  function (func, initialValue) {
    var arr = this
   
    var base = typeof initialValue === 'undefined' ? arr[0] : initialValue
    var startPoint = typeof initialValue === 'undefined' ? 1 : 0
    arr.slice(startPoint).forEach(function (val, index) {
        base = func(base, val, index + startPoint, arr)
    })
    return base
}

var arr = [1, 2, 3, 4];
arr.reduce((total, currentValue, currentIndex, arr) => {
    console.log(total, currentValue, currentIndex, arr)
    return total + currentValue
}, 10)
    </script>
```

注意：其中foreach：![image-20210106160516860](/image-20210106160516860.png)

#### js如何实现绑定：call，bind，apply简单说了一下区别

三个函数存在的作用**改变函数执行时的上下文**，再具体一点就是**改变函数运行时的this指向**

[call，apply的区别](https://github.com/qianguyihao/Web/blob/master/06-JavaScript%E8%BF%9B%E9%98%B6/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB.md)

![image-20210106171333161](/image-20210106171333161.png)

#### 浏览器的存储机制（4种）和缓存机制

![image-20210106184827439](/image-20210106184827439.png)

[浏览器常见数据存储方案](https://juejin.cn/post/6844904193694646280)

[浏览器的存储与缓存机制（补充）](https://blog.csdn.net/wantingtr/article/details/100559520)

##### 手写试下LocalStorage

```js
API参考
1：增加了一个数据项目
localStorage.setItem('myCat', 'Tom');
2：读取 localStorage 项
localStorage.getItem('myCat');
3：移除 localStorage 项
localStorage.removeItem('myCat');
4：移除所有的 localStorage 项
localStorage.clear();jsj
5:key(index)方法允许获取一个指定位置的键值
localStorage.key(index); 
```

```js
<script>
        // 模拟实现Locastorage
        // 使用map作为数据结构
        let valuemap= new Map();
        class Localstorage{
            // 根据key获得value
            getItem(key){
              const stringkey=String(key);
              if(valuemap.has(key)){
                  return valuemap.get(key);
              }
              // 未存在
              return null;

            }
            // 插入值
            setItem(key,val){
                valuemap.set(String(key),String(val));
            }


            removeItem(key){
                valuemap.delete(key);
            }

            clear(){
                valuemap.clear();
            }
            key(i){
                if(arguments.length==0){
                    throw new TypeError("Failed to execute");
                }
                let arr=Array.from(valuemap.keys());
                return arr[i];
            }
            get length(){
                return valuemap.size;
            }

        }
    </script>
```

```js
const instance = new LocalStorage()

global.localStorage = new Proxy(instance, {
  set: function (obj, prop, value) {
    if (LocalStorage.prototype.hasOwnProperty(prop)) {
      instance[prop] = value
    } else {
      instance.setItem(prop, value)
    }
    return true
  },
  get: function (target, name) {
    if (LocalStorage.prototype.hasOwnProperty(name)) {
      return instance[name]
    }
    if (valuesMap.has(name)) {
      return instance.getItem(name)
    }
  }
})


```



#### promise

##### 优点

​	实现异步操作，通过链式调用解决回调地狱（也就是层层嵌套问题）

##### 不同时期的promise对应的状态

- 初始化状态（等待状态）：pending
- 成功状态：fulfilled
- 失败状态：rejected

（1）当 new Promise()执行之后，promise 对象的状态会被初始化为`pending`，这个状态是初始化状态。`new Promise()`这行代码，括号里的内容是同步执行的。括号里定义一个 function，function 有两个参数：resolve 和 reject。如下：

- 如果请求成功了，则执行 resolve()，此时，promise 的状态会被自动修改为 fulfilled。
- 如果请求失败了，则执行 reject()，此时，promise 的状态会被自动修改为 rejected

（2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2：

- 如果 promise 的状态为 fulfilled（意思是：如果请求成功），则执行 function1 里的内容
- 如果 promise 的状态为 rejected（意思是，如果请求失败），则执行 function2 里的内容

##### sync await和promise的区别

三者都是实现异步编程

1 ：promise是ES6，async/await是ES7

2：Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。

3   reject状态：    

​	1）promise错误可以通过catch来捕捉，建议尾部捕获错误，   

​	2）async/await既可以用.then又可以用try-catch捕捉

3：async await与Promise一样，是非阻塞的。

4：async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。

##### 手写promise

[参考](https://juejin.cn/post/6850037281206566919#heading-6)

```js

// 基础版的 Promise  但是没有处理异步
<script>
        // 手写promoise
        // 三个状态
        const PENDING ="PENDING";
        const FULFILLED="FULFILLED";
        const REJECTED="REJECTED";

        class Promise{
            constructor(executor){
                 // 默认状态为 PENDING
                 this.status=PENDING;
                 // 存放成功状态的值，默认为 undefined
                 this.value=undefined;
                 // 存放失败状态的值，默认为 undefined
                 this.reason=undefined;
                 // 调用此方法就是成功
                 let resolve=(value)=>{
                   if(this.status===PENDING)
                     {
                       this.status=FULFILLED;
                    this.value=value;
                     }      
                }
                // 调用此方法就是失败
                let reject=(reason)=>{
                    if(this.status==PENDING){
                        this.status=REJECTED;
                        this.reason=reason;
                    }
                }

                try{
                    // 立即执行，将resolve和reject函数传给使用者
                    executor(resolve,reject)
                }catch(error){
                    reject(error);
                }
            }  
              // 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected
            then(onFulfilled,onRejected){
                if(this.status===FULFILLED){
                    onFulfilled(this.value);
                }
                if(this.status===REJECTED){
                    onRejected(this.reason);
                }
            } 
        }
    </script>
```

###### promise优化代码

```js
        // 手写promoise
        // 三个状态
        const PENDING ="PENDING";
        const FULFILLED="FULFILLED";
        const REJECTED="REJECTED";

        class Promise{
            constructor(executor){
                 // 默认状态为 PENDING
                 this.status=PENDING;
                 // 存放成功状态的值，默认为 undefined
                 this.value=undefined;
                 // 存放失败状态的值，默认为 undefined
                 this.reason=undefined;
                 // 调用此方法就是成功
                 // 存放成功的回调
                this.onResolvedCallbacks = [];
                // 存放失败的回调
                this.onRejectedCallbacks= [];

                 let resolve=(value)=>{
                   if(this.status===PENDING)
                   {
                    this.status=FULFILLED;
                    this.value=value;
                    this.onResolvedCallbacks.forEach(fn=>fn());
                   }
                    

                }
                // 调用此方法就是失败
                let reject=(reason)=>{
                    if(this.status==PENDING){
                        this.status=REJECTED;
                        this.reason=reason; 
                        this.onRejectedCallbacks.forEach(fn=>fn());
                    }
                }

                try{
                    // 立即执行，将resolve和reject函数传给使用者
                    executor(resolve,reject)
                }catch(error){
                    reject(error);
                }
            }  
              // 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected
            then(onFulfilled,onRejected){
                if(this.status===FULFILLED){
                    onFulfilled(this.value);
                }
                if(this.status===REJECTED){
                    onRejected(this.reason);
                }
                if (this.status === PENDING) {
                    // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
                    this.onResolvedCallbacks.push(() => {
                        onFulfilled(this.value)
                    });

                    // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
                    this.onRejectedCallbacks.push(()=> {
                        onRejected(this.reason); })
                }
            } 
        }
```



##### 手写promise.all

```js
function promiseAll(promises) {
  return new Promise(function(resolve, reject) {
    if (!isArray(promises)) {
      return reject(new TypeError('arguments must be an array'));
    }
    var resolvedCounter = 0;
    var promiseNum = promises.length;
    var resolvedValues = new Array(promiseNum);
    for (var i = 0; i < promiseNum; i++) {
      (function(i) {
        Promise.resolve(promises[i]).then(function(value) {
          resolvedCounter++
          resolvedValues[i] = value
          if (resolvedCounter == promiseNum) {
            return resolve(resolvedValues)
          }
        }, function(reason) {
          return reject(reason)
        })
      })(i)
    }
  })
}

```

其中：

​	![image-20210107153102229](/image-20210107153102229.png)

##### 手写promise.race

```js
  Promise.race = function(promises) {
    return new Promise(function(resolve, reject) {
      for (var i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i]).then(function(value) {
          return resolve(value)
        }, function(reason) {
          return reject(reason)
        })
      }
    })
  }
```



##### 参考

[非常不错](https://github.com/qianguyihao/Web/blob/master/05-JavaScript%E4%B9%8BES6%E8%AF%AD%E6%B3%95/10-Promise%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3.md)

注意：

​	链式调用指的是 .then().then().then()这样

​	then((data)=>)  这里面的data需要的是前面resolve(数据)返回出来



#### 宏任务、微任务

![image-20210106193224175](/image-20210106193224175.png)

注意：**每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。**

```js
setTimeout(_ => console.log(4))

new Promise(resolve => {
  resolve()
  console.log(1)
}).then(_ => {
  console.log(3)
})

console.log(2)

结果：1，2，3，4
```

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

结果：

 	  1:首先出现 code ，因为他是常规的同步调用
 	  2：promise第二个出现，因为then会通过微任务队列，并在当前代码之后执行
 		3：timeout最后显示，因为他是一个宏任务

​	

```js
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');

```

 正确答案是：script start, script end, promise1, promise2, setTimeout

注意：![image-20210106195557900](/image-20210106195557900.png)

注意到

​		Promise参数中的Promise1是同步执行的

​		不是把所以的宏任务一下子进行，比如先进行scrpit下的同步任务，然后进行里面的异步任务（微任务），然后在找里面队列最先得宏任务  注意仔细思考下面得序号图 比如是先进行setout下得同步任务，然后进行下面得微任务，开始下一个settimeout任务

[宏任务和微任务（非常好）](https://juejin.cn/post/6844903638238756878)

![image-20210107170318104](/image-20210107170318104.png)

#### 正则表达式

##### [正则表达式的符号](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)

[常见正则表达式面试题](https://blog.csdn.net/beichen3997/article/details/78694013)

## 2021.1.7

#### instanceOf和typeOf的区别

typeof是判断变量的类型，instanceof 是判断对象（引用）的类型

#### CSS定位

##### static（静态定位)

- 默认值，设置 top，right，bottom，left 这些偏移属性不会影响静态定位的正常显示(设置这些属性没有用)。
- 块级元素从上到下依次排列，框之间的垂直距离由框的垂直margin计算得到。行内元素在一行中水平布置。这个就不过多描述了。

##### 相对定位

- 元素相对自身偏移某个位置，元素扔保持其未定位的形状，它原本所占用的空间扔保留，可以通过 z-index 进行层次分级，子元素可相对该元素进行绝对定位;

##### 绝对定位

- 绝对定位的盒子脱离了标准文档流
- 1）如果用**top描述**，那么参考点就是**页面的左上角**，而不是浏览器的左上角：
- （2）如果用**bottom描述**，那么参考点就是**浏览器首屏窗口尺寸**（好好理解“首屏”二字），对应的页面的左下角：
-  absolute（绝对定位）绝对定位元素以父辈元素中最近的定位元素为参考坐标，如果绝对定位元素的父辈元素中没有采用定位的，那么此绝对定位元素的参考对象是html,元素会脱离文档流。就好像文档流中被删除了一样。并且定位元素经常与z-index属性进行层次分级

##### 固定定位

​	就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变

#### 元素水平垂直居中方式

- absolute加margin方案
- fixed 加 margin 方案
- display:table 方案
- 行内元素line-height方案
- flex 弹性布局方案
- transform 未知元素宽高解决方案

[元素水平垂直居中方式](https://juejin.cn/post/6844903766437838862)

#### margin/padding百分比计算

[margin/padding百分比计算](https://segmentfault.com/a/1190000016226944)

[解析](https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/)

### `['1', '2', '3'].map(parseInt)`

答案:**真正的答案是[1, NaN, NaN]**

![image-20210107173624608](/image-20210107173624608.png)

[标准解答](https://blog.csdn.net/freshlover/article/details/19034079)

### 2021.1.8

#### 如何判断数组类型

1：使用instanceof方法判断

2：使用数组自带的isArray方法

3：使用函数construor：但注意这个属性可以更改

```
const a = [];
console.log(a.constructor);//function Array(){ [native code] }
```

### 2021.1.9

##### Vue路由面试题

[Vue路由面试题](https://juejin.cn/post/6844903961745440775)

#### 比较代码不同

```js
比较下面两段代码，试述两段代码的不同之处
// A--------------------------
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();

// B---------------------------
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

## Webpack学习

#### 作用域

访问的可达性。

#### 命名空间

可以来解决命名冲突的能力。 

#### 模块化

- 封装
- 重用性
- 解除耦合

#### 打包工具

Gulp和Grunt是自动化构建工具，打包只是其中一部分。

webpack是模块化打包工具

#### webpack打包机制

![image-20210109211959840](/image-20210109211959840.png)

![image-20210109211932398](/image-20210109211932398.png)

##### webpack与立即执行函数的关系

##### webpack打包的核心逻辑

loader文件加载器

plugins：uglifyjs：去掉不必要的东西：注释等

## 对象

#### 属性类型

##### 数据类型

要修改属性的默认的特性：使用ECMAScript5的：Object.defineProperty()方法。接受三个参数：属性所在的对象、属性的名字和一个描述符对象。其中描述符对象的数据属性configurable，enumerale，writeable和value。

![image-20210112135917262](/image-20210112135917262.png)

![image-20210112135904312](/image-20210112135904312.png)

##### 访问器属性

访问器属性不包括数据值，他们包含一对geter和setter函数（不过，这两个函数不是必须的）

![image-20210112140334732](/image-20210112140334732.png)

### 继承

主要分为接口继承（继承方法签名）和实现继承（继承实际的方法）。

实现继承主要依靠原型链来实现的。

##### 构造函数式继承

使用.call方式去继承

```js
function Parent(color) {

this.color = color;
this.print = function() {
    console.log(this.color);
}
}
```

```js
// 子类构造函数
function Son(color) {

Parent.call(this, color);
}
```

```js
var son1 = new Son('red');
son1.print(); // red
​
var son2 = new Son('blue');
son2.print(); // blue
```

##### 原型链式继承

作为是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

```js
function Parent() {

this.color = 'red';
this.print = function() {
    console.log(this.color);
}
}

function Son() {
}

我们有一个父类和一个空的子类；

Son.prototype = new Parent();
Son.prototype.constructor = Son;
    接着我们把子函数的原型属性赋值给了父函数的实例；

var son1 = new Son();
son1.print(); // red
    最后新建子类实例，调用父类的方法，成功拿到父类的color和print属性方法；
```

缺点：所有的子实例的属性和方法，都在父类同一个实例上了

##### 组合式继承

```js
var obj = {

color: 'red',
print: function() {
    console.log(this.color);
}
};
​
var son1 = Object.create(obj);
son1.print(); // red
​
var son2 = Object.create(obj);
son2.print(); // red
```

​	寄生式继承本质上还是原型链继承，Object.create(obj);方法意思是以obj为原型构造对象，所以寄生式继承不需要构造函数，但是同样有着原型链继承的优缺点，也就是它把所有的属性和方法都共享了。

##### es6继承

```js
//class 相当于es5中构造函数
//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中
//class中定义的所有方法是不可枚举的
//class中只能定义方法，不能定义对象，变量等
//class和方法内默认都是严格模式
//es5中constructor为隐式属性
class People{
  constructor(name='wang',age='27'){
    this.name = name;
    this.age = age;
  }
  eat(){
    console.log(`${this.name} ${this.age} eat food`)
  }
}
//继承父类
class Woman extends People{ 
   constructor(name = 'ren',age = '27'){ 
     //继承父类属性
     super(name, age); 
   } 
    eat(){ 
     //继承父类方法
      super.eat() 
    } 
} 
let wonmanObj=new Woman('xiaoxiami'); 
wonmanObj.eat();
```

### 2021.1.12

#### CSS画三角形和正方形

实际都是夹出来的。

##### 上三角

```js
div{
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 100px solid red;

        }
```

##### 下三角

```js
div{
            width: 0;
            height: 0;
            border-top: 100px solid  red;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
        }
```

#### CSS布局

[参考](https://juejin.cn/post/6844903491891118087)

##### 传统布局模式

`display` 属性（文档流布局） + `position` 属性（定位布局） + `float`属性（浮动布局）

##### Flex布局

​	flex 的使用方法很简单，只需要将其 `display` 属性设置为 `flex` 就可以，也可以设置行内的 flex，记得 Webkit 内核的浏览器，必须加上 `-webkit` 前缀。

**注意，设为 Flex 布局以后，子元素的 `float`、`clear` 和 `vertical-align` 属性将失效。**

```js
   .ele{
       display: -webkit-flex;
       display: flex;
       display: inline-flex;
       display: -webkit-inline-flex;
   }

```

​	在使用 flex 的元素中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）
​	主轴开始的位置称为 `main start`，主轴结束的位置称为 `main end`。
同理，交叉轴开始的位置称为 `cross start`，交叉轴结束的位置称为 `cross end`。
​	在使用 flex 的子元素中，占据的主轴空间叫做 `main size`，占据的交叉轴空间叫做 `cross size`。

![image-20210112161958315](/image-20210112161958315.png)

但这只是一维布局。

##### Grid布局

​	`grid` 布局不需要在 HTML 中使用特定的标签布局，所有的布局都是在 CSS 中完成的，你可以随意定义你的 grid 网格。

​	通过display属性设置属性值为 grid 或 inline-grid 或者是 subgrid（该元素父元素为网格，继承父元素的行和列的大小）

**注：当元素设置了网格布局，column、float、clear、vertical-align属性无效。**

#### 拷贝

#### 数组的深浅拷贝

[参考](https://segmentfault.com/a/1190000015042902)

##### 浅拷贝

如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。

注释：只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。

##### 深拷贝

完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。

注释：`递归`拷贝目标对象的所有属性

##### 深拷贝和浅拷贝的对比

如果直接var a=object（b)  那么两个里面基本数据类型和引用类型都是一起的，一个变，另外一个就变。

###### 层次

- **浅拷贝** 只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。
- **深拷贝**不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是`递归`拷贝目标对象的所有属性。

###### 是否开辟新的栈

- **浅拷贝** 对于目标对象第一层为`基本数据类型`的数据，就是直接赋值，即「传值」；而对于目标对象第一层为`引用数据类型`的数据，就是直接赋存于栈内存中的堆内存地址,即「传址」,并`没有开辟新的栈`，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变，
- **深拷贝** 而深复制则是`开辟新的栈`，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。

```js
let obj={
            name:"唐苗",
            sun:function(name){
                this.name=name;
            }
        }
        let obj2=obj; 
        obj2.name="唐苗2";
        obj2.sun("吉奥");
        console.log(obj.name);    
        console.log(obj2.name);
```

结果两个对象一起变换。

##### 实现浅拷贝的方式

还是只赋值目标对象的第一层属性。

###### Array.concat()

```js
   const arr = [1,2,3,4,[5,6]];
   const copy = arr.concat(); \\ 利用concat()创建arr的副本
   
   \\改变基本类型值,不会改变原数组
   copy[0] = 2; 
   arr; //[1,2,3,4,[5,6]];

   \\改变数组中的引用类型值，原数组也会跟着改变
   copy[4][1] = 7;
   arr; //[1,2,3,4,[5,7]];
   
```

###### 插入一个知识点

```js
   const arr = [1,2,3,4,[5,6]];
   const copy = arr.concat(); \\ 利用concat()创建arr的副本
   
   \\改变基本类型值,不会改变原数组
   copy[0] = 2; 
   arr; //[1,2,3,4,[5,6]];

   \\改变数组中的引用类型值，原数组也会跟着改变
   copy[4][1] = 7;
   arr; //[1,2,3,4,[5,7]];
   
```

前后打印的值是一样的。

[参考](https://segmentfault.com/q/1010000017100551)

###### **Object.assign()**

```js
const obj1 = {x: 1, y: 2};
const obj2 = Object.assign({}, obj1);

obj2.x = 2; \\修改obj2.x,改变对象中的基本类型值
console.log(obj1) //{x: 1, y: 2} //原对象未改变
console.log(obj2) //{x: 2, y: 2}

const obj1 = {
    x: 1, 
    y: {
        m: 1
    }
};
const obj2 = Object.assign({}, obj1);

obj2.y.m = 2; \\修改obj2.y.m,改变对象中的引用类型值
console.log(obj1) //{x: 1, y: {m: 2}} 原对象也被改变
console.log(obj2) //{x: 2, y: {m: 2}}

```

##### 深拷贝

###### JSON.parse()和JSON.stringify()

parse()用于将一个字符串解析成一个json对象

stringify()是从一个对象中解析出字符串

```js
const obj1 = {
    x: 1, 
    y: {
        m: 1
    }
};
const obj2 = JSON.parse(JSON.stringify(obj1));
console.log(obj1) //{x: 1, y: {m: 1}}
console.log(obj2) //{x: 1, y: {m: 1}}

obj2.y.m = 2; //修改obj2.y.m
console.log(obj1) //{x: 1, y: {m: 1}} 原对象未改变
console.log(obj2) //{x: 2, y: {m: 2}}
```

- undefined、任意的函数、正则表达式类型以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时)；
- 它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object；
- 如果对象中存在循环引用的情况无法正确处理。

###### 递归

```js
function deepCopy1(obj) {
    // 创建一个新对象
    let result = {}
    let keys = Object.keys(obj),
        key = null,
        temp = null;

    for (let i = 0; i < keys.length; i++) {
        key = keys[i];    
        temp = obj[key];
        // 如果字段的值也是一个对象则递归操作
        if (temp && typeof temp === 'object') {
            result[key] = deepCopy(temp);
        } else {
        // 否则直接赋值给新对象
            result[key] = temp;
        }
    }
    return result;
}

const obj1 = {
    x: {
        m: 1
    },
    y: undefined,
    z: function add(z1, z2) {
        return z1 + z2
    },
    a: Symbol("foo")
};

const obj2 = deepCopy1(obj1);
obj2.x.m = 2;

console.log(obj1); //{x: {m: 1}, y: undefined, z: ƒ, a: Symbol(foo)}
console.log(obj2); //{x: {m: 2}, y: undefined, z: ƒ, a: Symbol(foo)}
```

缺点：不能避免循环引用

##### 循环引用

###### 父级引用

​	当对象的某个属性，正是这个对象本身，此时我们如果进行深拷贝，可能会在子元素->父对象->子元素...这个循环中一直进行，导致栈溢出。

```js
 const obj1 = {
    x: 1, 
    y: 2
};
obj1.z = obj1;

const obj2 = deepCopy1(obj1); \\栈溢出
```

​		解决办法是:只需要判断一个对象的字段是否引用了这个对象或这个对象的任意父级即可，可以修改上面的deepCopy1函数:

```js
function deepCopy2(obj, parent=null) {
    //创建一个新对象
    let result = {};
    let keys = Object.keys(obj),
         key = null,
         temp = null,
         _parent = parent;
    //该字段有父级则需要追溯该字段的父级
    while(_parent) {
        //如果该字段引用了它的父级，则为循环引用
        if(_parent.originParent === obj) {
            //循环引用返回同级的新对象
            return _parent.currentParent;
        }
        _parent = _parent.parent
    }
    for(let i=0,len=keys.length;i<len;i++) {
        key = keys[i]
        temp = obj[key]
        // 如果字段的值也是一个新对象
        if(temp && typeof temp === 'object') {
            result[key] = deepCopy(temp, {
                //递归执行深拷贝，将同级的待拷贝对象与新对象传递给parent，方便追溯循环引用
                originParent: obj,
                currentParent: result,
                parent: parent
            });
        } else {
            result[key] = temp;
        }
    }
    return result;
}

const obj1 = {
    x:1
}
obj1.z = obj1;

const obj2 = deepCopy2(obj1);

```

###### 同级引用

​	假设对象obj有a,b,c三个子对象，其中子对象c中有个属性d引用了对象obj下面的子对象a。

```js
const obj= {
    a: {
        name: 'a'
    },
    b: {
        name: 'b'
    },
    c: {

    }
};
c.d.e = obj.a;
```

​	此时c.d.e和obj.a 是相等的，因为它们引用的是同一个对象

```js
  console.log(c.d.e === obj.a); //true
```

​	如果我们调用上面的deepCopy2函数

```js
const copy = deepCopy2(obj);
console.log(copy.a); // 输出： {name: "a"}
console.log(copy.d.e);// 输出: {name: "a"}
console.log(copy.a === copy.d.e); // 输出： false
```

​	以上表现我们就可以看出，虽然opy.a 和copy.d.e在字面意义上是相等的，但二者并不是引用的同一个对象，这点上来看对象copy和原对象obj还是有差异的。

​	这种情况是因为obj.a并不在obj.d.e的父级对象链上，所以deepCopy2函数就无法检测到obj.d.e对obj.a也是一种引用关系，所以deepCopy2函数就将obj.a深拷贝的结果赋值给了copy.d.e。

```js
function deepCopy3(obj) {
    // hash表，记录所有的对象的引用关系
    let map = new WeakMap();
    function dp(obj) {
        let result = null;
        let keys = Object.keys(obj);
        let key = null,
            temp = null,
            existobj = null;

        existobj = map.get(obj);
        //如果这个对象已经被记录则直接返回
        if(existobj) {
            return existobj;
        }

        result = {}
        map.set(obj, result);

        for(let i =0,len=keys.length;i<len;i++) {
            key = keys[i];
            temp = obj[key];
            if(temp && typeof temp === 'object') {
                result[key] = dp(temp);
            }else {
                result[key] = temp;
            }
        }
        return result;
    }
    return dp(obj);
}

const obj= {
    a: {
        name: 'a'
    },
    b: {
        name: 'b'
    },
    c: {

    }
};
c.d.e = obj.a;

const copy = deepCopy3(obj);
```

#### 1.13微派面试

1：Http的三次握手，四次挥手  这个答出来了

2：实现继承和call（）方法附加bind和apply

3：flex布局及其优点

4：promise和awaite的比较

5：v-if和v-show的区别

6：

```js
<script>
         let a=10;
        let obj={
            a:20,
            w:function(){
                console.log(this.a);
                a=30;
             }
         }
         obj.w();
         let c=obj;
         c.w();

         console.log(a);
         console.log(obj.a);
         
</script>
```

答案：20，20，30，20

7：Es6有哪些新的特性

 答出：箭头函数（还问相关特点），let const var区别

8：eventloop事件循环

https://juejin.cn/post/6868849475008331783

​	未答出

9：原生的绑定事件有哪几种？

10：讲一下原型链

11：说一下盒模型

12：watcher和computed几个的区别

13：迭代器和生成器

[MDN里面的](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators)

## 2021.2.18面试学习

#### 手写instanceof

首先 instanceof 左侧必须是对象, 才能找到它的原型链

instanceof 右侧必须是函数, 函数才会prototype属性

迭代 , 左侧对象的原型不等于右侧的 prototype时, 沿着原型链重新赋值左侧

```js
      // [1,2,3] instanceof Array ---- true

      // L instanceof R
      // 变量R的原型 存在于 变量L的原型链上
      function instance_of(L, R) {
        const baseURL = ["string", "undefined", "symbol", "boolean", "number"];
        if (baseURL.includes(typeof L)) return false;
        // 取原型链
        let RP = R.prototype;
         L = Object.getPrototypeOf(L);
         // 也对于 L=L.__proto__
        while(true){
            if(L === null)
                return false;
            else if(L=== RP)
                return true;
            L=Object.getPrototypeOf(L)
        }
      }

      console.log(instance_of([1,2,3],Array));
```

**为何Object instanceof Function和Function instanceof Object都返回true？**

Object, Function, Array等等这些都被称作是构造“函数”，他们都是函数。而所有的函数都是构造函数Function的实例。从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Function构造函数的构造原型Function.protorype对象，所以：

```
alert(Object instanceof Function);// return true
```

与此同时，又因为Function.prototype是一个对象，所以他的构造函数是Object. 从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Object构造函数的构造原型Object.prototype对象，所以：

```
alert(Function instanceof Object);// return true
```

有趣的是根据我们通过原型链机制对instanceof进行的分析，我们不难得出一个结论：Function instanceof Function 依然返回true, 原理是一样的

\1. Function是构造函数，所以它是函数对象

\2. 函数对象都是由Function构造函数创建而来的，原型链机制解释为：函数对象的原型链中存在Function.prototype

\3. instanceof查找原型链中的每一个节点，如果Function.prototype的构造函数Function的原型链中被查到，返回true

因此下面代码依然返回true

```
alert(Function instanceof Function);// still true
```

#### 手写函数柯里化

实现多个数的和

sum(1,2,3)

sum(1)(2)(3)

```js
      function sum() {
         // 说把调用方法的参数截取出来。
        let allArgs = Array.prototype.slice.call(arguments);
        let add = function() {
          allArgs.push(...arguments); // 每次调用 sum 函数都收集参数
          return add;
        };
        // 重写 toString 方法，函数执行的时候会自动调用toString()方法，计算返回所有参数结果
        add.toString = function() {
          return allArgs.reduce((a, b) => a + b);
        };
        return add;
      }
      console.log(sum(1,2));  
```

Array.prototype.push.apply(a, b)  和 a.push(b)  和[].push.apply(a, b) 都是将b追加到a里面

如果此时a的值为null, undefined, Function时，会报错，

如果为number, string, boolean, 不会报错，但是也没有任何意义。

如果为数组或者一般对象，则会将b追加到a中。a自身的长度也会发生变化。

## 2021.2.20字节

计算机网络

ipv4和ipv6的区别，子网掩码的作用。

进程之间如何通信

tcp三次握手，四次挥手的原因

http2（）

cdn

浏览器的事件模型，事件委托

js为什么是单线程的

js有那些数据类型

如何判断引用类型的区别object.protptype.toString

new的实现内容

[]==(![]) 这是类型的转换

this指向有哪些类别

call，apply  bind的区别和手写

闭包

vue v-if 和v-show有什么区别

data()为什么不能是对象

v-modle 的实现：有哪两个

父子组件的生命周期：主要是mounted

算法：链接是否有环。