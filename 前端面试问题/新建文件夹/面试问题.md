---
typora-root-url: 图片
typora-copy-images-to: 图片
---

# 面试问题

链接：[手写35道面试高频题](https://juejin.cn/post/6870043180444680200)

## 2021.1.6

#### 解决闭包

```js
for (var a = 0; a<200; a++) { setTimeout(() => console.log(a), 1000) }
```

原因：产生了闭包，等函数执行完之后a的值已经是200了

##### 使用立即函数解决闭包

​		思路：匿名函数内的变量i与外部函数的变量i的引用关系断掉

```js
for (var a = 0; a <20; a++) {
           (function(index){
                    setTimeout(() => console.log(index), 1000) 
                }(a));
            }
```

##### 使用promise解决闭包

[promise的理解](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)

[廖学峰的promise](https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544)

[promise语法：resolve和reject](https://juejin.cn/post/6844903604009041928)

```js
 				const tasks=[];
        const output=function(index){
            new Promise(
              (resolve)=>{
                setTimeout(() =>{ console.log(index);  resolve()}, 10) ;
            })
        }         
 
        for (var a = 0; a <20; a++) {
                tasks.push(output(a));
            }
        Promise.all(tasks).then(()=>{
               console.log("全部打印成功");
            })
```

#### 三握四挥：tcp传输层

##### 三次握手

syn同步位（只有连接请求或者连接请求的接受为1），seq是序号位（随机产生） ACK确认位（与ack【确认号字段】搭配使用）

ack是对上一个号的确认

![image-20210106150947279](/image-20210106150947279.png)

![image-20210106145112108](/image-20210106145112108.png)

##### 四次挥手

![image-20210106145203649](/image-20210106145203649.png)

FIN结束位，

![image-20210106151414292](/image-20210106151414292.png)

##### syn攻击

tcp连接时第二次和第三次分别分配缓存和变量，会产生syn泛洪攻击。就是攻击者不进行第三步反馈

![image-20210106150632296](/image-20210106150632296.png)

解决办法：设置syncookie

##### 为什么前面需要三次握手，后面却是四次挥手

​	这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。

##### TCP连接第三次可以发送数据吗

​	客户端发送这个报文之后，就进入established状态了。服务器收到这个报文之后，也进入established状态。

​	TCP标准规定，第三次握手的报文，可以携带数据。因为此时客户端已经处于established状态了呀

![image-20210106151845094](/image-20210106151845094.png)

##### 全连接和半连接队列（三次握手）

![image-20210106162130026](/image-20210106162130026.png)

![image-20210106162204037](/image-20210106162204037.png)

##### 链接：[三握四挥](https://zhuanlan.zhihu.com/p/53374516)

#### Http和Https的区别

主要理解http是超文本传输协议，https主要是在http上+ssl（加密方法）传输

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。

- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。

- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

  [Http和Https的区别](https://www.runoob.com/w3cnote/http-vs-https.html)

  ##### 常见http状态码

  ​	![image-20210106201027234](/image-20210106201027234.png)

  200-请求成功

  301 资源被永久转移到其他URL

  404-请求资源不存在

  500-内部服务器错误

  

#### 基本数据类型（7+1）

基本数据类型null，undefined，string，number，boolean，symbol(这是es6引入的一种新的原始数据 类型，表示独一无二的值)

引用数据类型：一般统称为对象类型，但细分的话有：对象（object）数组（Array）函数（Function) Data类型，RegExp 类型

注意：Symbol 生成一个全局唯一的值。写法：var symbol() :括号里面可以用字符串表示值，但其实括号里面的值没什么关系

![image-20210107132635423](/image-20210107132635423.png)



#### Javasc中reduce方法手动实现

![image-20210106153853419](/image-20210106153853419.png)

![image-20210106154027207](/image-20210106154027207.png)

注意：在没有初始值的空数组上调用 reduce 将报错

```js
<script>
     Array.prototype.reduce =  function (func, initialValue) {
    var arr = this
   
    var base = typeof initialValue === 'undefined' ? arr[0] : initialValue
    var startPoint = typeof initialValue === 'undefined' ? 1 : 0
    arr.slice(startPoint).forEach(function (val, index) {
        base = func(base, val, index + startPoint, arr)
    })
    return base
}

var arr = [1, 2, 3, 4];
arr.reduce((total, currentValue, currentIndex, arr) => {
    console.log(total, currentValue, currentIndex, arr)
    return total + currentValue
}, 10)
    </script>
```

注意：其中foreach：![image-20210106160516860](/image-20210106160516860.png)

#### js如何实现绑定：call，bind，apply简单说了一下区别

三个函数存在的作用**改变函数执行时的上下文**，再具体一点就是**改变函数运行时的this指向**

[call，apply的区别](https://github.com/qianguyihao/Web/blob/master/06-JavaScript%E8%BF%9B%E9%98%B6/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB.md)

![image-20210106171333161](/image-20210106171333161.png)

#### 浏览器的存储机制（4种）和缓存机制

![image-20210106184827439](/image-20210106184827439.png)

[浏览器常见数据存储方案](https://juejin.cn/post/6844904193694646280)

[浏览器的存储与缓存机制（补充）](https://blog.csdn.net/wantingtr/article/details/100559520)

##### 手写试下LocalStorage

```js
API参考
1：增加了一个数据项目
localStorage.setItem('myCat', 'Tom');
2：读取 localStorage 项
localStorage.getItem('myCat');
3：移除 localStorage 项
localStorage.removeItem('myCat');
4：移除所有的 localStorage 项
localStorage.clear();jsj
5:key(index)方法允许获取一个指定位置的键值
localStorage.key(index); 
```

```js
<script>
        // 模拟实现Locastorage
        // 使用map作为数据结构
        let valuemap= new Map();
        class Localstorage{
            // 根据key获得value
            getItem(key){
              const stringkey=String(key);
              if(valuemap.has(key)){
                  return valuemap.get(key);
              }
              // 未存在
              return null;

            }
            // 插入值
            setItem(key,val){
                valuemap.set(String(key),String(val));
            }


            removeItem(key){
                valuemap.delete(key);
            }

            clear(){
                valuemap.clear();
            }
            key(i){
                if(arguments.length==0){
                    throw new TypeError("Failed to execute");
                }
                let arr=Array.from(valuemap.keys());
                return arr[i];
            }
            get length(){
                return valuemap.size;
            }

        }
    </script>
```

```js
const instance = new LocalStorage()

global.localStorage = new Proxy(instance, {
  set: function (obj, prop, value) {
    if (LocalStorage.prototype.hasOwnProperty(prop)) {
      instance[prop] = value
    } else {
      instance.setItem(prop, value)
    }
    return true
  },
  get: function (target, name) {
    if (LocalStorage.prototype.hasOwnProperty(name)) {
      return instance[name]
    }
    if (valuesMap.has(name)) {
      return instance.getItem(name)
    }
  }
})


```



#### promise

##### 优点

​	实现异步操作，通过链式调用解决回调地狱（也就是层层嵌套问题）

##### 不同时期的promise对应的状态

- 初始化状态（等待状态）：pending
- 成功状态：fulfilled
- 失败状态：rejected

（1）当 new Promise()执行之后，promise 对象的状态会被初始化为`pending`，这个状态是初始化状态。`new Promise()`这行代码，括号里的内容是同步执行的。括号里定义一个 function，function 有两个参数：resolve 和 reject。如下：

- 如果请求成功了，则执行 resolve()，此时，promise 的状态会被自动修改为 fulfilled。
- 如果请求失败了，则执行 reject()，此时，promise 的状态会被自动修改为 rejected

（2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2：

- 如果 promise 的状态为 fulfilled（意思是：如果请求成功），则执行 function1 里的内容
- 如果 promise 的状态为 rejected（意思是，如果请求失败），则执行 function2 里的内容

##### sync await和promise的区别

三者都是实现异步编程

1 ：promise是ES6，async/await是ES7

2：Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。

3   reject状态：    

​	1）promise错误可以通过catch来捕捉，建议尾部捕获错误，   

​	2）async/await既可以用.then又可以用try-catch捕捉

3：async await与Promise一样，是非阻塞的。

4：async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。

##### 手写promise

[参考](https://juejin.cn/post/6850037281206566919#heading-6)

```js

// 基础版的 Promise  但是没有处理异步
<script>
        // 手写promoise
        // 三个状态
        const PENDING ="PENDING";
        const FULFILLED="FULFILLED";
        const REJECTED="REJECTED";

        class Promise{
            constructor(executor){
                 // 默认状态为 PENDING
                 this.status=PENDING;
                 // 存放成功状态的值，默认为 undefined
                 this.value=undefined;
                 // 存放失败状态的值，默认为 undefined
                 this.reason=undefined;
                 // 调用此方法就是成功
                 let resolve=(value)=>{
                   if(this.status===PENDING)
                     {
                       this.status=FULFILLED;
                    this.value=value;
                     }      
                }
                // 调用此方法就是失败
                let reject=(reason)=>{
                    if(this.status==PENDING){
                        this.status=REJECTED;
                        this.reason=reason;
                    }
                }

                try{
                    // 立即执行，将resolve和reject函数传给使用者
                    executor(resolve,reject)
                }catch(error){
                    reject(error);
                }
            }  
              // 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected
            then(onFulfilled,onRejected){
                if(this.status===FULFILLED){
                    onFulfilled(this.value);
                }
                if(this.status===REJECTED){
                    onRejected(this.reason);
                }
            } 
        }
    </script>
```

###### promise优化代码

```js
        // 手写promoise
        // 三个状态
        const PENDING ="PENDING";
        const FULFILLED="FULFILLED";
        const REJECTED="REJECTED";

        class Promise{
            constructor(executor){
                 // 默认状态为 PENDING
                 this.status=PENDING;
                 // 存放成功状态的值，默认为 undefined
                 this.value=undefined;
                 // 存放失败状态的值，默认为 undefined
                 this.reason=undefined;
                 // 调用此方法就是成功
                 // 存放成功的回调
                this.onResolvedCallbacks = [];
                // 存放失败的回调
                this.onRejectedCallbacks= [];

                 let resolve=(value)=>{
                   if(this.status===PENDING)
                   {
                    this.status=FULFILLED;
                    this.value=value;
                    this.onResolvedCallbacks.forEach(fn=>fn());
                   }
                    

                }
                // 调用此方法就是失败
                let reject=(reason)=>{
                    if(this.status==PENDING){
                        this.status=REJECTED;
                        this.reason=reason; 
                        this.onRejectedCallbacks.forEach(fn=>fn());
                    }
                }

                try{
                    // 立即执行，将resolve和reject函数传给使用者
                    executor(resolve,reject)
                }catch(error){
                    reject(error);
                }
            }  
              // 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected
            then(onFulfilled,onRejected){
                if(this.status===FULFILLED){
                    onFulfilled(this.value);
                }
                if(this.status===REJECTED){
                    onRejected(this.reason);
                }
                if (this.status === PENDING) {
                    // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
                    this.onResolvedCallbacks.push(() => {
                        onFulfilled(this.value)
                    });

                    // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
                    this.onRejectedCallbacks.push(()=> {
                        onRejected(this.reason); })
                }
            } 
        }
```



##### 手写promise.all

```js
function promiseAll(promises) {
  return new Promise(function(resolve, reject) {
    if (!isArray(promises)) {
      return reject(new TypeError('arguments must be an array'));
    }
    var resolvedCounter = 0;
    var promiseNum = promises.length;
    var resolvedValues = new Array(promiseNum);
    for (var i = 0; i < promiseNum; i++) {
      (function(i) {
        Promise.resolve(promises[i]).then(function(value) {
          resolvedCounter++
          resolvedValues[i] = value
          if (resolvedCounter == promiseNum) {
            return resolve(resolvedValues)
          }
        }, function(reason) {
          return reject(reason)
        })
      })(i)
    }
  })
}

```

其中：

​	![image-20210107153102229](/image-20210107153102229.png)

##### 手写promise.race

```js
  Promise.race = function(promises) {
    return new Promise(function(resolve, reject) {
      for (var i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i]).then(function(value) {
          return resolve(value)
        }, function(reason) {
          return reject(reason)
        })
      }
    })
  }
```



##### 参考

[非常不错](https://github.com/qianguyihao/Web/blob/master/05-JavaScript%E4%B9%8BES6%E8%AF%AD%E6%B3%95/10-Promise%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3.md)

注意：

​	链式调用指的是 .then().then().then()这样

​	then((data)=>)  这里面的data需要的是前面resolve(数据)返回出来



#### 宏任务、微任务

![image-20210106193224175](/image-20210106193224175.png)

注意：**每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。**

```js
setTimeout(_ => console.log(4))

new Promise(resolve => {
  resolve()
  console.log(1)
}).then(_ => {
  console.log(3)
})

console.log(2)

结果：1，2，3，4
```

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

结果：

 	  1:首先出现 code ，因为他是常规的同步调用
 	  2：promise第二个出现，因为then会通过微任务队列，并在当前代码之后执行
 		3：timeout最后显示，因为他是一个宏任务

​	

```js
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');

```

 正确答案是：script start, script end, promise1, promise2, setTimeout

注意：![image-20210106195557900](/image-20210106195557900.png)

注意到

​		Promise参数中的Promise1是同步执行的

​		不是把所以的宏任务一下子进行，比如先进行scrpit下的同步任务，然后进行里面的异步任务（微任务），然后在找里面队列最先得宏任务  注意仔细思考下面得序号图 比如是先进行setout下得同步任务，然后进行下面得微任务，开始下一个settimeout任务

[宏任务和微任务（非常好）](https://juejin.cn/post/6844903638238756878)

![image-20210107170318104](/image-20210107170318104.png)

#### 正则表达式

##### [正则表达式的符号](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)

[常见正则表达式面试题](https://blog.csdn.net/beichen3997/article/details/78694013)

## 2021.1.7

#### instanceOf和typeOf的区别

typeof是判断变量的类型，instanceof 是判断对象（引用）的类型

#### CSS定位

##### static（静态定位)

- 默认值，设置 top，right，bottom，left 这些偏移属性不会影响静态定位的正常显示(设置这些属性没有用)。
- 块级元素从上到下依次排列，框之间的垂直距离由框的垂直margin计算得到。行内元素在一行中水平布置。这个就不过多描述了。

##### 相对定位

- 元素相对自身偏移某个位置，元素扔保持其未定位的形状，它原本所占用的空间扔保留，可以通过 z-index 进行层次分级，子元素可相对该元素进行绝对定位;

##### 绝对定位

- 绝对定位的盒子脱离了标准文档流
- 1）如果用**top描述**，那么参考点就是**页面的左上角**，而不是浏览器的左上角：
- （2）如果用**bottom描述**，那么参考点就是**浏览器首屏窗口尺寸**（好好理解“首屏”二字），对应的页面的左下角：
-  absolute（绝对定位）绝对定位元素以父辈元素中最近的定位元素为参考坐标，如果绝对定位元素的父辈元素中没有采用定位的，那么此绝对定位元素的参考对象是html,元素会脱离文档流。就好像文档流中被删除了一样。并且定位元素经常与z-index属性进行层次分级

##### 固定定位

​	就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变

#### 元素水平垂直居中方式

- absolute加margin方案
- fixed 加 margin 方案
- display:table 方案
- 行内元素line-height方案
- flex 弹性布局方案
- transform 未知元素宽高解决方案

[元素水平垂直居中方式](https://juejin.cn/post/6844903766437838862)

#### margin/padding百分比计算

[margin/padding百分比计算](https://segmentfault.com/a/1190000016226944)

#### 浏览器输入url到渲染页面后发生了什么

- DNS解析
- TCP连接（三次握手）
- 发送Http请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束（四次挥手）

[解析](https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/)

### `['1', '2', '3'].map(parseInt)`

答案:**真正的答案是[1, NaN, NaN]**

![image-20210107173624608](/image-20210107173624608.png)

[标准解答](https://blog.csdn.net/freshlover/article/details/19034079)

### 2021.1.8

#### 如何判断数组类型

1：使用instanceof方法判断

2：使用数组自带的isArray方法

3：使用函数construor：但注意这个属性可以更改

```
const a = [];
console.log(a.constructor);//function Array(){ [native code] }
```

### 2021.1.9

##### Vue路由面试题

[Vue路由面试题](https://juejin.cn/post/6844903961745440775)

#### 比较代码不同

```js
比较下面两段代码，试述两段代码的不同之处
// A--------------------------
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();

// B---------------------------
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

## Webpack学习

#### 作用域

访问的可达性。

#### 命名空间

可以来解决命名冲突的能力。 

#### 模块化

- 封装
- 重用性
- 解除耦合

#### 打包工具

Gulp和Grunt是自动化构建工具，打包只是其中一部分。

webpack是模块化打包工具

#### webpack打包机制

![image-20210109211959840](/image-20210109211959840.png)

![image-20210109211932398](/image-20210109211932398.png)

##### webpack与立即执行函数的关系

##### webpack打包的核心逻辑

loader文件加载器

plugins：uglifyjs：去掉不必要的东西：注释等

## 对象

#### 属性类型

##### 数据类型

要修改属性的默认的特性：使用ECMAScript5的：Object.defineProperty()方法。接受三个参数：属性所在的对象、属性的名字和一个描述符对象。其中描述符对象的数据属性configurable，enumerale，writeable和value。

![image-20210112135917262](/image-20210112135917262.png)

![image-20210112135904312](/image-20210112135904312.png)

##### 访问器属性

访问器属性不包括数据值，他们包含一对geter和setter函数（不过，这两个函数不是必须的）

![image-20210112140334732](/image-20210112140334732.png)

### 继承

主要分为接口继承（继承方法签名）和实现继承（继承实际的方法）。

实现继承主要依靠原型链来实现的。

##### 构造函数式继承

使用.call方式去继承

```js
function Parent(color) {

this.color = color;
this.print = function() {
    console.log(this.color);
}
}
```

```js
// 子类构造函数
function Son(color) {

Parent.call(this, color);
}
```

```js
var son1 = new Son('red');
son1.print(); // red
​
var son2 = new Son('blue');
son2.print(); // blue
```

##### 原型链式继承

作为是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

```js
function Parent() {

this.color = 'red';
this.print = function() {
    console.log(this.color);
}
}

function Son() {
}

我们有一个父类和一个空的子类；

Son.prototype = new Parent();
Son.prototype.constructor = Son;
    接着我们把子函数的原型属性赋值给了父函数的实例；

var son1 = new Son();
son1.print(); // red
    最后新建子类实例，调用父类的方法，成功拿到父类的color和print属性方法；
```

缺点：所有的子实例的属性和方法，都在父类同一个实例上了

##### 组合式继承

```js
var obj = {

color: 'red',
print: function() {
    console.log(this.color);
}
};
​
var son1 = Object.create(obj);
son1.print(); // red
​
var son2 = Object.create(obj);
son2.print(); // red
```

​	寄生式继承本质上还是原型链继承，Object.create(obj);方法意思是以obj为原型构造对象，所以寄生式继承不需要构造函数，但是同样有着原型链继承的优缺点，也就是它把所有的属性和方法都共享了。

##### es6继承

```js
//class 相当于es5中构造函数
//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中
//class中定义的所有方法是不可枚举的
//class中只能定义方法，不能定义对象，变量等
//class和方法内默认都是严格模式
//es5中constructor为隐式属性
class People{
  constructor(name='wang',age='27'){
    this.name = name;
    this.age = age;
  }
  eat(){
    console.log(`${this.name} ${this.age} eat food`)
  }
}
//继承父类
class Woman extends People{ 
   constructor(name = 'ren',age = '27'){ 
     //继承父类属性
     super(name, age); 
   } 
    eat(){ 
     //继承父类方法
      super.eat() 
    } 
} 
let wonmanObj=new Woman('xiaoxiami'); 
wonmanObj.eat();
```

### 2021.1.12

#### CSS画三角形和正方形

实际都是夹出来的。

##### 上三角

```js
div{
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 100px solid red;

        }
```

##### 下三角

```js
div{
            width: 0;
            height: 0;
            border-top: 100px solid  red;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
        }
```

#### CSS布局

[参考](https://juejin.cn/post/6844903491891118087)

##### 传统布局模式

`display` 属性（文档流布局） + `position` 属性（定位布局） + `float`属性（浮动布局）

##### Flex布局

​	flex 的使用方法很简单，只需要将其 `display` 属性设置为 `flex` 就可以，也可以设置行内的 flex，记得 Webkit 内核的浏览器，必须加上 `-webkit` 前缀。

**注意，设为 Flex 布局以后，子元素的 `float`、`clear` 和 `vertical-align` 属性将失效。**

```js
   .ele{
       display: -webkit-flex;
       display: flex;
       display: inline-flex;
       display: -webkit-inline-flex;
   }

```

​	在使用 flex 的元素中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）
​	主轴开始的位置称为 `main start`，主轴结束的位置称为 `main end`。
同理，交叉轴开始的位置称为 `cross start`，交叉轴结束的位置称为 `cross end`。
​	在使用 flex 的子元素中，占据的主轴空间叫做 `main size`，占据的交叉轴空间叫做 `cross size`。

![image-20210112161958315](/image-20210112161958315.png)

但这只是一维布局。

##### Grid布局

​	`grid` 布局不需要在 HTML 中使用特定的标签布局，所有的布局都是在 CSS 中完成的，你可以随意定义你的 grid 网格。

​	通过display属性设置属性值为 grid 或 inline-grid 或者是 subgrid（该元素父元素为网格，继承父元素的行和列的大小）

**注：当元素设置了网格布局，column、float、clear、vertical-align属性无效。**

#### 拷贝

#### 数组的深浅拷贝

[参考](https://segmentfault.com/a/1190000015042902)

##### 浅拷贝

如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。

注释：只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。

##### 深拷贝

完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。

注释：`递归`拷贝目标对象的所有属性

##### 深拷贝和浅拷贝的对比

如果直接var a=object（b)  那么两个里面基本数据类型和引用类型都是一起的，一个变，另外一个就变。

###### 层次

- **浅拷贝** 只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。
- **深拷贝**不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是`递归`拷贝目标对象的所有属性。

###### 是否开辟新的栈

- **浅拷贝** 对于目标对象第一层为`基本数据类型`的数据，就是直接赋值，即「传值」；而对于目标对象第一层为`引用数据类型`的数据，就是直接赋存于栈内存中的堆内存地址,即「传址」,并`没有开辟新的栈`，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变，
- **深拷贝** 而深复制则是`开辟新的栈`，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。

```js
let obj={
            name:"唐苗",
            sun:function(name){
                this.name=name;
            }
        }
        let obj2=obj; 
        obj2.name="唐苗2";
        obj2.sun("吉奥");
        console.log(obj.name);    
        console.log(obj2.name);
```

结果两个对象一起变换。

##### 实现浅拷贝的方式

还是只赋值目标对象的第一层属性。

###### Array.concat()

```js
   const arr = [1,2,3,4,[5,6]];
   const copy = arr.concat(); \\ 利用concat()创建arr的副本
   
   \\改变基本类型值,不会改变原数组
   copy[0] = 2; 
   arr; //[1,2,3,4,[5,6]];

   \\改变数组中的引用类型值，原数组也会跟着改变
   copy[4][1] = 7;
   arr; //[1,2,3,4,[5,7]];
   
```

###### 插入一个知识点

```js
   const arr = [1,2,3,4,[5,6]];
   const copy = arr.concat(); \\ 利用concat()创建arr的副本
   
   \\改变基本类型值,不会改变原数组
   copy[0] = 2; 
   arr; //[1,2,3,4,[5,6]];

   \\改变数组中的引用类型值，原数组也会跟着改变
   copy[4][1] = 7;
   arr; //[1,2,3,4,[5,7]];
   
```

前后打印的值是一样的。

[参考](https://segmentfault.com/q/1010000017100551)

###### **Object.assign()**

```js
const obj1 = {x: 1, y: 2};
const obj2 = Object.assign({}, obj1);

obj2.x = 2; \\修改obj2.x,改变对象中的基本类型值
console.log(obj1) //{x: 1, y: 2} //原对象未改变
console.log(obj2) //{x: 2, y: 2}

const obj1 = {
    x: 1, 
    y: {
        m: 1
    }
};
const obj2 = Object.assign({}, obj1);

obj2.y.m = 2; \\修改obj2.y.m,改变对象中的引用类型值
console.log(obj1) //{x: 1, y: {m: 2}} 原对象也被改变
console.log(obj2) //{x: 2, y: {m: 2}}

```

##### 深拷贝

###### JSON.parse()和JSON.stringify()

parse()用于将一个字符串解析成一个json对象

stringify()是从一个对象中解析出字符串

```js
const obj1 = {
    x: 1, 
    y: {
        m: 1
    }
};
const obj2 = JSON.parse(JSON.stringify(obj1));
console.log(obj1) //{x: 1, y: {m: 1}}
console.log(obj2) //{x: 1, y: {m: 1}}

obj2.y.m = 2; //修改obj2.y.m
console.log(obj1) //{x: 1, y: {m: 1}} 原对象未改变
console.log(obj2) //{x: 2, y: {m: 2}}
```

- undefined、任意的函数、正则表达式类型以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时)；
- 它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object；
- 如果对象中存在循环引用的情况无法正确处理。

###### 递归

```js
function deepCopy1(obj) {
    // 创建一个新对象
    let result = {}
    let keys = Object.keys(obj),
        key = null,
        temp = null;

    for (let i = 0; i < keys.length; i++) {
        key = keys[i];    
        temp = obj[key];
        // 如果字段的值也是一个对象则递归操作
        if (temp && typeof temp === 'object') {
            result[key] = deepCopy(temp);
        } else {
        // 否则直接赋值给新对象
            result[key] = temp;
        }
    }
    return result;
}

const obj1 = {
    x: {
        m: 1
    },
    y: undefined,
    z: function add(z1, z2) {
        return z1 + z2
    },
    a: Symbol("foo")
};

const obj2 = deepCopy1(obj1);
obj2.x.m = 2;

console.log(obj1); //{x: {m: 1}, y: undefined, z: ƒ, a: Symbol(foo)}
console.log(obj2); //{x: {m: 2}, y: undefined, z: ƒ, a: Symbol(foo)}
```

缺点：不能避免循环引用

##### 循环引用

###### 父级引用

​	当对象的某个属性，正是这个对象本身，此时我们如果进行深拷贝，可能会在子元素->父对象->子元素...这个循环中一直进行，导致栈溢出。

```js
 const obj1 = {
    x: 1, 
    y: 2
};
obj1.z = obj1;

const obj2 = deepCopy1(obj1); \\栈溢出
```

​		解决办法是:只需要判断一个对象的字段是否引用了这个对象或这个对象的任意父级即可，可以修改上面的deepCopy1函数:

```js
function deepCopy2(obj, parent=null) {
    //创建一个新对象
    let result = {};
    let keys = Object.keys(obj),
         key = null,
         temp = null,
         _parent = parent;
    //该字段有父级则需要追溯该字段的父级
    while(_parent) {
        //如果该字段引用了它的父级，则为循环引用
        if(_parent.originParent === obj) {
            //循环引用返回同级的新对象
            return _parent.currentParent;
        }
        _parent = _parent.parent
    }
    for(let i=0,len=keys.length;i<len;i++) {
        key = keys[i]
        temp = obj[key]
        // 如果字段的值也是一个新对象
        if(temp && typeof temp === 'object') {
            result[key] = deepCopy(temp, {
                //递归执行深拷贝，将同级的待拷贝对象与新对象传递给parent，方便追溯循环引用
                originParent: obj,
                currentParent: result,
                parent: parent
            });
        } else {
            result[key] = temp;
        }
    }
    return result;
}

const obj1 = {
    x:1
}
obj1.z = obj1;

const obj2 = deepCopy2(obj1);

```

###### 同级引用

​	假设对象obj有a,b,c三个子对象，其中子对象c中有个属性d引用了对象obj下面的子对象a。

```js
const obj= {
    a: {
        name: 'a'
    },
    b: {
        name: 'b'
    },
    c: {

    }
};
c.d.e = obj.a;
```

​	此时c.d.e和obj.a 是相等的，因为它们引用的是同一个对象

```js
  console.log(c.d.e === obj.a); //true
```

​	如果我们调用上面的deepCopy2函数

```js
const copy = deepCopy2(obj);
console.log(copy.a); // 输出： {name: "a"}
console.log(copy.d.e);// 输出: {name: "a"}
console.log(copy.a === copy.d.e); // 输出： false
```

​	以上表现我们就可以看出，虽然opy.a 和copy.d.e在字面意义上是相等的，但二者并不是引用的同一个对象，这点上来看对象copy和原对象obj还是有差异的。

​	这种情况是因为obj.a并不在obj.d.e的父级对象链上，所以deepCopy2函数就无法检测到obj.d.e对obj.a也是一种引用关系，所以deepCopy2函数就将obj.a深拷贝的结果赋值给了copy.d.e。

```js
function deepCopy3(obj) {
    // hash表，记录所有的对象的引用关系
    let map = new WeakMap();
    function dp(obj) {
        let result = null;
        let keys = Object.keys(obj);
        let key = null,
            temp = null,
            existobj = null;

        existobj = map.get(obj);
        //如果这个对象已经被记录则直接返回
        if(existobj) {
            return existobj;
        }

        result = {}
        map.set(obj, result);

        for(let i =0,len=keys.length;i<len;i++) {
            key = keys[i];
            temp = obj[key];
            if(temp && typeof temp === 'object') {
                result[key] = dp(temp);
            }else {
                result[key] = temp;
            }
        }
        return result;
    }
    return dp(obj);
}

const obj= {
    a: {
        name: 'a'
    },
    b: {
        name: 'b'
    },
    c: {

    }
};
c.d.e = obj.a;

const copy = deepCopy3(obj);
```

#### 1.13微派面试

1：Http的三次握手，四次挥手  这个答出来了

2：实现继承和call（）方法附加bind和apply

3：flex布局及其优点

4：promise和awaite的比较

5：v-if和v-show的区别

6：

```js
<script>
         let a=10;
        let obj={
            a:20,
            w:function(){
                console.log(this.a);
                a=30;
             }
         }
         obj.w();
         let c=obj;
         c.w();

         console.log(a);
         console.log(obj.a);
         
</script>
```

答案：20，20，30，20

7：Es6有哪些新的特性

 答出：箭头函数（还问相关特点），let const var区别

8：eventloop事件循环

https://juejin.cn/post/6868849475008331783

​	未答出

9：原生的绑定事件有哪几种？

10：讲一下原型链

11：说一下盒模型

12：watcher和computed几个的区别

13：迭代器和生成器

[MDN里面的](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators)

## 2021.2.18面试学习

#### 手写instanceof

首先 instanceof 左侧必须是对象, 才能找到它的原型链

instanceof 右侧必须是函数, 函数才会prototype属性

迭代 , 左侧对象的原型不等于右侧的 prototype时, 沿着原型链重新赋值左侧

```js
      // [1,2,3] instanceof Array ---- true

      // L instanceof R
      // 变量R的原型 存在于 变量L的原型链上
      function instance_of(L, R) {
        const baseURL = ["string", "undefined", "symbol", "boolean", "number"];
        if (baseURL.includes(typeof L)) return false;
        // 取原型链
        let RP = R.prototype;
         L = Object.getPrototypeOf(L);
         // 也对于 L=L.__proto__
        while(true){
            if(L === null)
                return false;
            else if(L=== RP)
                return true;
            L=Object.getPrototypeOf(L)
        }
      }

      console.log(instance_of([1,2,3],Array));
```

**为何Object instanceof Function和Function instanceof Object都返回true？**

Object, Function, Array等等这些都被称作是构造“函数”，他们都是函数。而所有的函数都是构造函数Function的实例。从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Function构造函数的构造原型Function.protorype对象，所以：

```
alert(Object instanceof Function);// return true
```

与此同时，又因为Function.prototype是一个对象，所以他的构造函数是Object. 从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Object构造函数的构造原型Object.prototype对象，所以：

```
alert(Function instanceof Object);// return true
```

有趣的是根据我们通过原型链机制对instanceof进行的分析，我们不难得出一个结论：Function instanceof Function 依然返回true, 原理是一样的

\1. Function是构造函数，所以它是函数对象

\2. 函数对象都是由Function构造函数创建而来的，原型链机制解释为：函数对象的原型链中存在Function.prototype

\3. instanceof查找原型链中的每一个节点，如果Function.prototype的构造函数Function的原型链中被查到，返回true

因此下面代码依然返回true

```
alert(Function instanceof Function);// still true
```

#### 手写函数柯里化

实现多个数的和

sum(1,2,3)

sum(1)(2)(3)

```js
      function sum() {
         // 说把调用方法的参数截取出来。
        let allArgs = Array.prototype.slice.call(arguments);
        let add = function() {
          allArgs.push(...arguments); // 每次调用 sum 函数都收集参数
          return add;
        };
        // 重写 toString 方法，函数执行的时候会自动调用toString()方法，计算返回所有参数结果
        add.toString = function() {
          return allArgs.reduce((a, b) => a + b);
        };
        return add;
      }
      console.log(sum(1,2));  
```

Array.prototype.push.apply(a, b)  和 a.push(b)  和[].push.apply(a, b) 都是将b追加到a里面

如果此时a的值为null, undefined, Function时，会报错，

如果为number, string, boolean, 不会报错，但是也没有任何意义。

如果为数组或者一般对象，则会将b追加到a中。a自身的长度也会发生变化。